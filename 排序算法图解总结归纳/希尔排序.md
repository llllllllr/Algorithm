希尔排序是将待排序的数组元素 按下标的一定增量分组 ，分成多个子序列，然后对各个子序列进行直接插入排序算法排序；然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序，排序结束。下面是希尔排序的步骤：

![希尔排序](https://github.com/llllllllr/Algorithm/blob/master/images/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg?raw=true)

**代码：**

```c++
void shellSort(int data[], int len)
{
	for (int gap = len / 2; gap > 0; gap /= 2)
	{
		for (int i = gap; i < len; i++)
		{
			int j = i;
			while (j > 0 && data[j] < data[j - gap])
			{
				swap(data[j], data[j - gap]);
				j-=gap;
			}
		}
	}
}
```

**复杂度分析**：

> 希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。

> **时间复杂度：**（n指待排序序列长度）
>  **1) 最好情况：**序列是正序排列，在这种情况下，需要进行的比较操作需（n-1）次。后移赋值操作为0次。即O(n)
>  **2) 最坏情况：**O(nlog2n)。
>  **3) 渐进时间复杂度（平均时间复杂度）：**O(nlog2n)

> 希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，**希尔排序的时间复杂度会比O(n²)好一些。**

> **稳定性**：由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是**不稳定**的。

参考链接：https://www.jianshu.com/p/d730ae586cf3

​                   https://www.cnblogs.com/chengxiao/p/6104371.html

