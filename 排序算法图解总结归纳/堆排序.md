> #### **堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。**

**代码**：

```c++
void max_heapify(int data[], int start, int end) {
	int dad = start;
	int son = dad * 2 + 1;
	while (son <= end)
	{
		if (son + 1 <= end && data[son + 1] > data[son])
			son++;
		if (data[son] < data[dad])
			return;
		else
		{
			swap(data[son], data[dad]);
			dad = son;
			son = dad * 2 + 1;
		}
	}
}

void heap_sort(int data[], int len) {
	for (int i = len / 2 - 1; i >= 0; i--)//从最后一个父节点开始从下往上
		max_heapify(data, i, len - 1);
	for (int i = len - 1; i > 0; i--)
	{
		swap(data[0], data[i]);
		max_heapify(data, 0, i - 1);
	}
}

```

**解释**：

> **一个重要的性质**：父节点的下标为**k**
>
> ​                               左孩子下标：**2*k+1**
>
> ​                                右孩子下标：**2*k+2**



上面的代码是将数组按从大到小排序的。

max_heapify()是将堆变成大顶堆。分解为小步骤就是令父节点最大。

![](https://github.com/llllllllr/Algorithm/blob/master/images/%E5%A0%86%E6%8E%92%E5%BA%8F.jpg?raw=true)

当一次堆排序结束，根节点就是最大的数再将根节点放到最后，再继续将堆变成最大堆。

**复杂度分析**：时间复杂度O(nlogn)，空间复杂度O(1)，不稳定排序

**与快速排序比较**：在堆排序（小根堆）的时候，每次总是将最小的元素移除，然后将最后的元素放到堆顶，再让其自我调整。这样一来，有很多比较将是被浪费的，因为被拿到堆顶的那个元素几乎肯定是很大的，而靠近堆顶的元素又几乎肯定是很小的，最后一个元素能留在堆顶的可能性微乎其微，最后一个元素很有可能最终再被移动到底部。在堆排序里面有大量这种近乎无效的比较。随着数据规模的增长，比较的开销最差情况应该在（线性*对数）级别，如果数据量是原来的10倍，那么用于比较的时间开销可能是原来的10log10倍。
        堆排序的过程中，需要有效的随机存取。比较父节点和字节点的值大小的时候，虽然计算下标会很快完成，但是在大规模的数据中对数组指针寻址也需要一定的时间。而快速排序只需要将数组指针移动到相邻的区域即可。在堆排序中，会大量的随机存取数据；而在快速排序中，只会大量的顺序存取数据。随着数据规模的扩大，这方面的差距会明显增大。在这方面的时间开销来说，快速排序只会线性增长，而堆排序增加幅度很大，会远远大于线性。

######         在快速排序中，每次数据移动都意味着该数据距离它正确的位置越来越近，而在堆排序中，类似将堆尾部的数据移到堆顶这样的操作只会使相应的数据远离它正确的位置，后续必然有一些操作再将其移动，即“做了好多无用功”。（参考：https://blog.csdn.net/u010189459/article/details/27702027）
**适用场景**：堆排序时间复杂度稳定，且在动态序列中比较有优势。例如在一个时间为O(nlgk)，将k个已排序链表合并为一个排序链表（此处的n为所有输入链表中元素的总数）。或者在STL中的std::sort中如果发现快速排序有明显退化迹象则回退到堆排序这样的时间复杂度稳定的排序上。

